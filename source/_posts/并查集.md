---
title: 并查集
tags: 数据结构
---
## 普通并查集

并查集研究一个集合中的元素是否有**关系**的数据结构，这个关系需要具有传递性。比如无向图中 `u` 和 `v` 是联通的，`v` 和 `t` 是联通的，那么 `u` 和 `t` 之间也是联通的。事实上并查集就是基于上面这个例子的一种数据结构。并查集顾名思义有两种操作：为两个元素添加关系，查询两个点之间是否具有关系。

并查集由若干个连通块组成，其中每一个连通块都是一棵树。换言之，并查集是一座森林。数组 `f[]` 记录每个点的前驱。最开始，每个点都是独立的，此时 `f[i] = i`。

### 查询两个点是否有关系

判断两个点是否在同一个连通块（树）中，只需要分别找到每个点所在树的根，然后判断是否相同即可。找根的函数这么写：

```cpp
int find(int x) {
    if(x == f[x]) return x;
    return find(f[x]);
}
```

容易发现如果 `x` 距离它的根很远的话，每次查找 `x` 的时间复杂度都会很爆炸。事实上，我们并不在意这棵树的结构，所以我们考虑直接破坏掉这棵树的结构，让 `x` 直接和根连接。这就是并查集的路径压缩。

```cpp
int find(int x) {
    if(x == f[x]) return x;
    return f[x] = find(f[x]);
}
```

### 为两个点添加关系

要让 `x` 和 `y` 处于同一个连通块内，只需要找到 `x` 的树根 `rx` 和 `y` 的树根 `ry`，然后连一条边（`f[y] = x`）即可.

```cpp
void merge(int x, int y) {
    x = find(x), y = find(y);
    if(x != y) f[y] = x;
}
```

### 板子

```cpp
struct DSU {
    int n;
    vector<int> siz, f;
    DSU(int n) : siz(n + 1, 1), f(n + 1) {
        iota(f.begin(), f.end(), 0);
    }
    int find(int x) {
        if(f[x] == x) return x;
        return f[x] = find(f[x]);
    }
    void merge(int x, int y) {
        x = find(x), y = find(y);
        if(x != y) f[y] = x, siz[x] += siz[y];
    }
    int size(int x) { return siz[find(x)]; }
};
```

### [【模板】并查集](https://www.luogu.com.cn/problem/P3367)

```cpp
struct DSU {
    int n;
    vector<int> siz, f;
    DSU(int n) : siz(n + 1, 1), f(n + 1) {
        iota(f.begin(), f.end(), 0);
    }
    int find(int x) {
        if(f[x] == x) return x;
        return f[x] = find(f[x]);
    }
    void merge(int x, int y) {
        x = find(x), y = find(y);
        if(x != y) f[y] = x, siz[x] += siz[y];
    }
    int size(int x) { return siz[find(x)]; }
};

void solve() {
    int n, m;
    cin >> n >> m;
    DSU dsu(n);
    while(m--) {
        int op, x, y;
        cin >> op >> x >> y;
        if(op == 1) {
            dsu.merge(x, y);
        } else {
            if(dsu.find(x) != dsu.find(y)) {
                cout << "N\n";
            } else cout << "Y\n";
        }
    }
}
```

### [程序自动分析](https://www.luogu.com.cn/problem/P1955)

看看数据范围，先离散化一下。然后先处理相等的条件，把他们用并查集连一下。然后再处理不相等的条件，如果查出他们是相等的，直接输出 `NO`

```cpp
struct lsh : vector<ll> {
    lsh(vector<ll>::iterator l, vector<ll>::iterator r) : vector<ll>(l, r) {
        sort(begin(), end());
        erase(unique(begin(), end()), end());
    };
    int rank(int x) {
        return lower_bound(begin(), end(), x) - begin() + 1;
    }
    ll kth(int x) { return at(x - 1); }
};

void solve() {
    int n, m;
    cin >> n;
    vector<ll> tmp;
    vector<array<int, 3>> a(n + 1);
    fu(i, 1, n) {
        cin >> a[i][0] >> a[i][1] >> a[i][2];
        tmp.eb(a[i][0]), tmp.eb(a[i][1]);
    }
    sort(a.begin() + 1, a.end(), [](array<int, 3> x, array<int, 3> y) {
        return x[2] > y[2];
    });
    lsh mp(tmp.begin(), tmp.end());
    
    DSU dsu(mp.size());
    for(int i = 1; i <= n; ++i) {
        auto [x, y, op] = a[i];
        x = mp.rank(x), y = mp.rank(y);
        if(op == 1) {
            dsu.merge(x, y);
        } else if(dsu.find(x) == dsu.find(y)){
            cout << "NO\n"; return;
        }
    }
    cout << "YES\n";
}
```

## 种类并查集（扩展域）

实际上我们遇到的问题中遇到的关系不仅是两两连接的这一种。可能是多种关系，而如果这多种关系构成一个环，就可以使用种类并查集。上文中提到的关系就是类似于朋友关系，朋友的朋友是朋友。而现在引入另一种关系：敌人。定义敌人的朋友是敌人，敌人的敌人是朋友，很容易会发现这种关系其实形成了一个二元环，这种情况下就可以使用种类并查集了。

对于有 $k$ 种关系的关系网，需要开 $k$ 倍大小的并查集。在上面的例子中，并查集的范围是 $[1, 2n]$，并查集分成了 $[1, n]$ 和 $[n + 1, 2n]$ 两个部分。如果需要构建朋友关系，那么就在每个部分中做连边，如果需要构建敌人关系，就需要在第 $1$ 个部分和第 $2$ 个部分间做连边。

```cpp
// x - y is Friend
dsu.merge(x, y), dsu.merge(x + n, y + n);
// x - y is Enemy
dsu.merge(x, y + n), dsu.merge(y, x + n);
```

假如是建立 $k$ 中关系中的第 $t$ 种关系，就需要在第 $i$ 个部分和第 $(i + t - 1) \bmod n + 1$ 个部分间做连边。原理其实并不好解释，但是理解起来并不难，所以希望可以自己画图自己理解，下面放例题.

### [关押罪犯](https://www.luogu.com.cn/problem/P1525)

由于答案为影响系数力最大的那个事件，所以我们贪心地先处理影响力系数大的事件，把这两个罪犯放在不同的监狱。直到无法处理，一定发生冲突的时候，输入该事件的影响力。注意如果不会发生冲突，需要输出 $0$

```cpp
void solve() {
    int n, m;
    cin >> n >> m;
    DSU dsu(2 * n);
    vector<array<int, 3>> a(m + 1);
    fu(i, 1, m) cin >> a[i][1] >> a[i][2] >> a[i][0];
    sort(a.rbegin(), a.rend() - 1);
    fu(i, 1, m) {
        auto [val, x, y] = a[i];
        if(dsu.find(x) == dsu.find(y)) {
            cout << val << endl; return;
        } else {
            dsu.merge(x, y + n), dsu.merge(y, x + n);
        }
    }
    cout << 0 << endl;
}
```

### [食物链](https://www.luogu.com.cn/problem/P2024)

这题涉及到了三种关系，如果懂了原理，怎么连边就很清楚了。如果你能想明白这题，那么种类并查集算是会了.

```cpp
void solve() {
    int n, m, ans = 0;
    cin >> n >> m;
    DSU dsu(3 * n);
    
    fu(i, 1, m) {
        int op, x, y;
        cin >> op >> x >> y;
        if(x > n || y > n) {
            ans++; continue;
        }
        if(op == 1) {
            if(dsu.find(x) == dsu.find(y + n) || dsu.find(x) == dsu.find(y + 2 * n)) ans++;
            else {
                dsu.merge(x, y);
                dsu.merge(x + n, y + n);
                dsu.merge(x + 2 * n, y + 2 * n);
            }
        } else {
            if(dsu.find(x) == dsu.find(y) || dsu.find(x) == dsu.find(y + n)) ans++;
            else {
                dsu.merge(x, y + 2 * n);
                dsu.merge(x + n, y);
                dsu.merge(x + 2 * n, y + n);
            }
        }
    }
    
    cout << ans << endl;
}
```

## 带权并查集

带权并查集指的就是边有边权，我们让 `dp[]` 表示 `x` 和 `f[x]` 之间连边的边权。那么路径压缩的时候，由于改变了树的结构，就需要更新 `dp[x]`。由于更新后 `x` 的前驱为树根 `rt`。

$$
\begin{aligned}
dp(x) &= val(x \to f(x))\\
dp(x)^\prime &= val(x \to rt) \\
val(x \to rt) &= val(x \to f(x)) + val(f(x) \to rt)\\
dp(f(x)) &= val(f(x) \to rt)
\end{aligned}
$$

结合一下可以计算出 $dp(x)^\prime = dp(x) + dp(f(x))$。

注意上面的 `+` 指的是广义的加，也就是两个数据进行合并。具体怎么合并需要看题目的要求。

例如种类并查集就可以借用这个权来实现，可以看看下文是怎么处理的。

### 板子

```cpp
struct DSU {
    vector<int> f, siz;
    vector<ll> dp;
    DSU(int n) : f(n + 1), siz(n + 1, 1), dp(n + 1) {
        iota(f.begin(), f.end(), 0);
    }
    int find(int x) {
        if(f[x] == x) return x;
        int fa = find(f[x]);
        dp[x] += dp[f[x]];
        return f[x] = fa;
    }
    // 如果你想要让 y 距离 x 为 t, 那么 val = dp[x] + t - dp[y]
    void merge(int x, int y, ll val) {
        x = find(x), y = find(y);
        if(x == y) return;
        f[y] = x, dp[y] = val, siz[x] += siz[y];
    }
    int size(int x) { return siz[find(x)]; }
};
```

### [关押罪犯](https://www.luogu.com.cn/problem/P1525)

```cpp
struct DSU {
    vector<int> f, siz;
    vector<ll> dp;
    DSU(int n) : f(n + 1), siz(n + 1, 1), dp(n + 1) {
        iota(f.begin(), f.end(), 0);
    }
    int find(int x) {
        if(f[x] == x) return x;
        int fa = find(f[x]);
        dp[x] ^= dp[f[x]];
        return f[x] = fa;
    }
    // 如果你想要让 y 距离 x 为 t, 那么 val = dp[x] + t - dp[y]
    void merge(int x, int y, ll val) {
        x = find(x), y = find(y);
        if(x == y) return;
        f[y] = x, dp[y] = val, siz[x] += siz[y];
    }
    int size(int x) { return siz[find(x)]; }
};

void solve() {
    int n, m;
    cin >> n >> m;
    DSU dsu(n);
    vector<array<int, 3>> a(m + 1);
    fu(i, 1, m) cin >> a[i][1] >> a[i][2] >> a[i][0];
    sort(a.rbegin(), a.rend() - 1);
    fu(i, 1, m) {
        auto [val, x, y] = a[i];
        int rx = dsu.find(x), ry = dsu.find(y);
        if(rx != ry) dsu.merge(rx, ry, dsu.dp[x] ^ dsu.dp[y] ^ 1);
        else if(dsu.dp[x] == dsu.dp[y]) {
            cout << val << endl; return;
        }
    }
    cout << 0 << endl;
}
```

### [食物链](https://www.luogu.com.cn/problem/P2024)

```cpp
struct DSU {
    vector<int> f, siz;
    vector<ll> dp;
    DSU(int n) : f(n + 1), siz(n + 1, 1), dp(n + 1) {
        iota(f.begin(), f.end(), 0);
    }
    int find(int x) {
        if(f[x] == x) return x;
        int fa = find(f[x]);
        (dp[x] += dp[f[x]]) %= 3;
        return f[x] = fa;
    }
    // 如果你想要让 y 距离 x 为 t, 那么 val = dp[x] + t - dp[y]
    void merge(int x, int y, ll val) {
        x = find(x), y = find(y);
        if(x == y) return;
        f[y] = x, dp[y] = (val % 3 + 3) % 3, siz[x] += siz[y];
    }
    int size(int x) { return siz[find(x)]; }
};

void solve() {
    int n, m, ans = 0;
    cin >> n >> m;
    DSU dsu(n);
    fu(i, 1, m) {
        int op, x, y;
        cin >> op >> x >> y;
        if(x > n || y > n || (op == 2 && x == y)) {
            ans++; continue;
        }
        int rx = dsu.find(x), ry = dsu.find(y);
        if(rx == ry) {
            if((op == 1 && ((dsu.dp[x] - dsu.dp[y]) % 3 + 3) % 3) ||
               (op == 2 && ((dsu.dp[x] - dsu.dp[y]) % 3 + 3) % 3 != 1)
            ) ans++;
        } else {
            dsu.merge(y, x, dsu.dp[y] + (op - 1) - dsu.dp[x]);
        }
    }
    cout << ans << endl;
}
```

### [银河英雄传说](https://www.luogu.com.cn/problem/P2024)

```cpp
struct DSU {
    vector<int> f, siz;
    vector<ll> dp;
    DSU(int n) : f(n + 1), siz(n + 1, 1), dp(n + 1) {
        iota(f.begin(), f.end(), 0);
    }
    int find(int x) {
        if(f[x] == x) return x;
        int fa = find(f[x]);
        dp[x] += dp[f[x]];
        return f[x] = fa;
    }
    void merge(int x, int y, ll val) {
        x = find(x), y = find(y);
        if(x == y) return;
        f[y] = x, siz[x] += siz[y], dp[y] = val;
    }
    int size(int u) { return siz[find(u)]; }
};

void solve() {
    int q;
    cin >> q;
    DSU dsu(maxn);
    while(q--) {
        char op;
        int x, y;
        cin >> op >> x >> y;
        if(op == 'M') {
            dsu.merge(y, x, dsu.size(y));
        } else {
            int rx = dsu.find(x), ry = dsu.find(y);
            if(rx != ry) cout << "-1\n";
            else cout << abs(dsu.dp[x] - dsu.dp[y]) - 1 << endl;
        }
    }
}
```

## addition - 利用并查集的根优化

给 $n$ 个点，你需要做 $m$ 次以下操作，每次操作给定一个区间 $[l, r]$，合并这个区间内的点。

考虑每次操作都是 $[1, n]$，那么直接操作一定会超时。我们利用并查集的根进行优化。注意到，`find(1), find(2), ..., find(n)` 其实是一段一段的，例如 $[1, 1, 1, 4, 5, 6, 6, 8, 8, 8]$。所以我们给并查集的根赋予一个现实意义：连通块的编号最大的点。还是上面的例子，第一个连通块由 $1, 2, 3$ 组成，那么让第一个连通块的根为 $3$。

考虑合并区间 $[l, r]$，从 $l$ 开始，每次合并这一块和下一块，这么说可能有点抽象，直接放代码吧，注意结合上面说的根的意义进行理解。

```cpp
for(int i = dsu.find(l); i != dsu.find(r); i = dsu.find(i + 1)) {
    dsu.merge(i + 1, i);
}
```

`i` 指的是所在连通块的根，依据并查集的根的意义，`i + 1` 一定是属于下一个连通块。连接 `i` 和 `i + 1` 所在的两个块后，`i` 跳到 `i + 1` 所在的块的根，即 `find(i + 1)`。直到 `i` 是最后一块时结束循环。

练习题（新手慎入）：[Atcoder364-F](https://atcoder.jp/contests/abc364/tasks/abc364_f)，[Codeforces2020-D](https://codeforces.com/contest/2020/problem/D)